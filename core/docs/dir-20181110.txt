Пути оптимизация очереди событий

1) Для ускорения доступа к полному списку типов, для которых необходимо
обеспечить генерацию и диспетчерезацию событий, подобный список можно
предварительно сформировать при использовании методов добавления и удаления
дублеров типа (alternates).

2) Если для каждого нового события есть некоторая работа, которую необходимо
выполнить перед диспетчерезацией, то распараллеливая эту работу по разным
потокам можно ускорить диспетчерезацию. Обработчики последовательных событий
могут стартовать в паралельных потоках, но обработчик более позднего события
должен дождаться, когда диспетчеризация более раннего события будет завершена.

3) Возможно, распаралеливание на уровне типа и всех его дублеров даст прирост,
вероятно совсем незначительный. Рассматривать данный путь в крайнюю очередь.

Учитывая порядок временных затрат на формирование списка типов в тестах
последовательной однопоточной диспетчерезации, наиболее перспективным выглядит
именно первый путь.

Рассмотрим этот вариант оптимизации более подробно.

Полный список типов, обслуживание которых требуется при отправке события данного
типа будем сокращенно называть ПСТ. Дублера рассматриваемого типа будем называть
- наш дублер. Дублер, который прямо или косвенно относится к нашему дублеру
будем называть - подчиненный дублер.

Наиболее сложную часть поддержания ПСТ в актуальном состоянии представляет собой
правило диспетчерезации событий, которое требует, что бы событие было
направленно наблюдателям данного типа события, наблюдателем всех дублеров, а в
случае наличия у наших дублеров собственных дублеров, то и наблюдателям всех
дублеров, имеющих косвенную связь с текущими типом (иерархия дублеров).
Сложность заключается в том, что если для нашего дублера в глубине дерева
зависимостей произойдет добавление или удаление подчиненного дублера, то
текущий тип события должен будет перестроить свой ПСТ. Однако текущая
реализация не позволяет каким либо образом отслеживать изменение состояния
типов.

Решить задачу можно путем имплементации классом типа события паттерна observer.
При добавлении дублера, текущий тип будет подписываться на его уведомления о
добавлении или удалении подчиненных дублеров. 

Проблема - при удалении нашего дублера мы не знаем какие типы ПСТ являются
подчиненными удаленному дублеру. Вообще, список можно перестраивать заново
каждый раз при удалении или добавлении нашего дублера. Корректировку списка
в случае удаления или добавления подчиненного дублера можно делать исключительно
на основе событий. Однако полное перестроение влечет проблемы с блокировкой.

Проблема - по сути у нас дерево связей. Два разных наших дублера могут иметь
подчиненным один и тот же тип. Если не учитывать количество ссылок в иерархии,
то при подаче уведомления подчиненный дублер будет удален преждевременно.
Значит нужно как то считать количество использований конкретного типа в
иерархии. Когда счетчик использований достигает нуля, то этот дублер удаляется,
а наблюдатели уведомляются об изменениях. При добавлении дублера или получения
уведомления от нижестоящего, если счетчик добавлен, значит вышестоящий
уведомляется о появлении нового дублера. 

Проблема с взаимными блокировками. Чтобы минимизировать вероятность дедлоков,
реализацию необходимо ограничить взаимодействием только с собственными
дублерами. Вместо обхода всех дублеров в иерархии, запрашивать список
подчиненных дублеров следует у нашего дублера. 

Еще по вопросу блокировок. Возможно имеет смысл передавать в методы уведомления
инстанс отправителя. По нему можно дополнительно проверить, следует ли
обрабатывать данное уведомление или это запоздавшее, пришедшее уже после
отписки при удалении дублера. Тогда проблем с дедлоками должно быть меньше.

Попробуем представить ситуацию, при которой у нас возникает взаимная блокировка
двух типов. Дедлок возможен только при участии как минимум двух потоков.
Теоретически, проблема может возникнуть когда мы внутри критической секции
уведомляем наблюдателей. У этих наблюдателей будут свои критические секции.

Для примера возьмем три типа A, B, C и два потока T1 и T2. Допустим в T1
для A добавляем дублером B и они оба заблокированы. При этом C является
наблюдателем A. Если в момент уведомления C, C из того же потока обратится к A
или B, то проблем не будет. Однако если в момент уведомления C будет на
блокировке из T2, ожидая захвата занятых в настоящий момент A или B, то
возникнет взаимная блокировка. Остается определить, в какой ситуации C из потока
T2 может захватить свой лок и обратиться к A или B. Такое возможно, если в
потоке T2 для C дублером добавляется A или B. При добавлении дублера
осуществляется захват мониторов текущего типа и типа-дублера. При этом
очередность захвата определяется хэш-значением. Предположим, тип C имеет
наименьшее из всех трех хэш-значение. Тогда условия для возникновения взаимной
блокировки:
* T1 добавляет для A дублера B и захватывает мониторы A и B;
* T2 добавляет для C дублера B и T2 захватывает монитор C, после чего встает на
  ожидание монитора B, который сейчас занят потоком T1;
* T1 в границах блокировки доходит до уведомления наблюдателей и пытается
  вызвать соответствующий метод C, который пытается захватить собственный
  монитор
В результате T1 ждет освобождения C, а T2 не отдает монитор C, пока не
освободится B, занятый потоком T1 - возникает взаимная блокировка. Таким
образом, уведомлять наблюдателей в границах блокировки нельзя.

Можно значительно упростить процесс и перестраивать ПСТ каждый раз при
получении уведомления от нашего дублера. Уведомление наблюдателей вынести за
пределы критической секции. Количество ссылок подсчитывать не требуется.
После каждого перестоения ПСТ, уведомлять наблюдателей, независимо от того,
изменился ли ПСТ по сравнению с предыдущим. В совокупности такой подход приведет
к более частым перестоениям ПСТ, однако учитывая частоту изменения списка
дублеров это будет не проблема. Единственное что нужно здесь уточнить,
если перестраивать ПСТ в пределах критической секции и там же опрашивать своих
дублеров на предмет их собственного ПСТ, не приведет ли это к взаимным
блокировкам?

Если тип A войдет в критическую секцию и начнет перебирать некие типы событий,
захватывая их монитор, возможна зеркальная ситуация, когда тип B - один из
элементов перебираемого типом A списка внутри собственной критической секции
перестраивает собственный ПСТ и косвенно пытается получить 

Максимально простой вариант - это оставить формирование ПСТ как есть, путем
обхода всех типов в иерархии и просто кешировать его в каждом типе. Формирование
ПСТ делать вне критической секции, а в границах критической секции выполнять
только сохранение ПСТ во внутренней переменной. Поскольку мы точно знаем, что
уведомления приходят после того как в иерархию внесены изменения, порядок
уведомлений становится не критичным. Самый негативный эффект, который можно
получить при таком подходе, это пропуск событий из-за небольшого запаздывания
при перестроении ПСТ. Однако данный эффект проявится только при активном
мультипоточном добавлении и удалении дублеров, что учитывая существующую
практику использования системы довольно редкий случай.

Директива 20151221
[[[[ О разделении модели терминала и источников данных ]]]]

Основание

Реализация терминалов на базе наследования базовой реализации терминала и
последующей реализации специфических механизмов доступа к источникам данных
внутри наследника не оправдала себя. При таком подходе сложно тестировать классы
верхнего уровня абстракции, так как они объединяют и базовую логику терминала, и
специфическую, сложность которой зависит от сложности удаленной системы.
Инстанцирование такого терминала связано с передачей большого числа аргументов,
состав которых специфичен от реализации к реализации. Жесткая привязка к
конкретным источникам данных в рамках одного экземпляра не позволяет
комбинировать источники данных для различных целей (например, эмуляция торгов на
базе реальных данных о торгах и эмулятора исполнения заявок).

--------------------------------------------------------------------------------

Подход

Принято решение обособить терминал в виде универсальной, независимой от
источников данных сущности и связать экземпляр терминала с поставщиками данных
путем использования дополнительного интерфейса. Таким образом, по отношению к
данным терминал будет выступать только инициатором запросов, а специфические
механизмы поставки данных будут скрыты за интерфейсом поставщика данных.

Остается открытым вопрос состояния терминала. Поскольку терминал больше не
отвечает за инициализацию подсистем и подключение к удаленным системам,
состояния started/stopped и connected/disconnected больше не имеют смысла для
терминала. Единственное актуальное состояние терминала теперь ready/unready.
Именно на эти события пользователи терминала обязаны назначать обработчики,
инициирующие запрос данных.

--------------------------------------------------------------------------------

Порядок редизайна

Все связанные объекты будут внедряться в момент инстанцирования, а это значит,
что управление зависимостями теперь лучше всего выполнять вне рамок терминала.
На переходный период предлагается сохранить такие сущности как стартер и
контроллер терминала. Это необходимо для сохранения работоспособности имеющихся
реализаций терминалов. Все методы или объекты, необязательные для новой схемы
работы, необходимо отметить как deprecated. После осуществления перехода на
новую схему, необходимо избавиться от deprecated элементов. 

Первым этапом необходимо перевести весь код на использование билдера базового
терминала. Это необходимо для того, что бы в последствии можно было свободно
изменять конструктор базового терминала. Объект параметров терминала, который
сейчас используется для передачи в качестве аргумента конструктора, следует
удалить, что бы обозначить точки внесения изменений.

Для обеспечения возможности использования одного экземпляра поставщика данных
для нескольких терминалов, необходимо снабдить каждый терминал уникальным в
рамках отдельного процесса идентификатором, который может быть использован
поставщиком для роутинга запросов к конкретным источникам данных.

Конструктор терминала должен быть упрощен. Рассмотрев возможные варианты
использования, можно с уверенностью утверждать, что будет достаточно двух 
конструкторов: конструктора без аргументов, который будет назначать
идентификатор терминала автоматически и конструктор с идентификатором терминала
в качестве аргумента.  При этом, для всех других объектов, ранее передаваемых в
конструктор, необходимо предусмотреть сеттеры. Работу билдера базового терминала
необходимо переписать на использование этих сеттеров. Кроме того, по-умолчанию
конструктор терминала должен инстанцировать все необходимые для работы объекты
их дефолтными реализациями. Для впрыска экземпляра провайдера данных так же
необходимо предусмотреть сеттер. При этом возможен вариант неконсистентного
состояния, когда терминал не был снабжен провайдером данных. Но такое состояние
мы оставим на откуп разработчику, потому что ситуация, когда провайдер не будет
использоваться довольно предсказуема (например, в рамках модульных тестов).

После этого, можно перевести базовую реализацию метода requestSecurity терминала
на обращение к провайдеру данных. Поскольку финальная реализация терминала
теперь будет единственной, класс терминала следует переименовать в нечто более
соответствующее.

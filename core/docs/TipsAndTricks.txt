

--------------------------------------------------------------------------------
- Мультипоточная обработка

При работе с терминалом из нескольких потоков синхронизацию типа ReentrantLock и
synchronized следует использовать с большой осторожностью, так как можно
получить взаимную блокировку потоков. Если функция потока использует
синхронизацию в целях гарантии консистентного состояния и при этом
осуществляется вызов метода некоторого внешнего объекта, то не следует
осуществлять этот вызов внутри блока синхронизации. Вместо этого следует
использовать временную переменную для сохранения ссылки на объект и осуществить
вызов с использованием этой переменной.

Например, имеется некий поток, осуществляющий чтение последовательности сделок
из файла и осуществляющий перенаправление этих сделок некоторому абстрактному
потребителю. Этот поток представлен в виде сервиса и снабжен методом, который
позволяет остановить чтение потока и трансляцию сделок. Поскольку этот сервис
подразумевает возможность обращения из нескольких потоков, то для гарантии
согласованного состояния (сервис в работе/сервис остановлен) используются блоки
синхронизации. Один для изменения состояния сервиса

	public void stopReadingUpdates() {
		lock.lock();
		try {
			if ( started ) {
				started = false;
			}
		} finally {
			lock.unlock();
		}
	}

другой для проверки этого состояния

	public void consumeUpdate(L1Update update, long sequenceID) {
		lock.lock();
		try {
			if ( started ) {
				consumer.consume(update);
			}
		} finally {
			lock.unlock();
		}
	}

Проблема данной реализации в том, что потребитель, которому передается
управление, может обратиться к ресурсу, который заблокирован другим потоком и
который из этого же потока пытаться остановить сервис вызовом метода
stopReadingUpdates. Таким образом, два потока заблокируют друг друга навсегда:
один поток будет ожидать освобождения ресурса, занимая лок, который нужен для
освобождения ресурса. А второй поток не сможет продолжить работу что бы
освободить лок, так как будет ожидать освобождения лока при входе в метод
stopReadingUpdates.

Что бы решить данную проблему следует использовать временную переменную ВСЕГДА,
когда управление передается внешнему объекту. Такой подход позволит осуществлять
любой рефакторинг, не беспокоясь о проблемах синхронизации не связанных между
собой компонентов системы. Безопасная с точки зрения блокировок реализация
метода consumeUpdate с использованием временной переменно может выглядеть
следующим образом:

	public void consumeUpdate(L1Update update, long sequenceID) {
		L1UpdateConsumer dummy = null;
		lock.lock();
		try {
			if ( started ) {
				dummy = consumer;
			}
		} finally {
			lock.unlock();
		}
		if ( dummy != null ) {
			dummy.consume(update);
		}
	}

--------------------------------------------------------------------------------
- Новые типы заявок

Новые типы заявок можно зарегистрировать, используя соотвествующие фабричные
методы класса OrderType. Единственным обязательным требованием при регистрации
новых типов является наличие уникального строкового идентификатора типа. Если
нужно добавить несколько дополнительных типов для последующего использования в
целях идентификации по экземпляру, следует использовать следующий подход:

	static final OrderType newType = OrderType.registerType("NewTypeID");

При необходимости класс OrderType может быть расширен дополнительными свойствами
и методами. В этом случае следует использовать метод регистрации нового
типа с экземпляром в качестве аргумента:

	static class MyOrderType extends OrderType {
		private final int newProp;
		
		protected MyOrderType(String code, int prop) {
			super(code);
			this.newProp = prop;
		}
		
	}
	
	static final MyOrderType FOO = (MyOrderType) OrderType.registerType(new MyOrderType("foo", 100));

Важно учитывать, что регистрация нового типа невозможна в случае дублирования
идентификатора.

--------------------------------------------------------------------------------
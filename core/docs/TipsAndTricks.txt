- Мультипоточная обработка

При работе с терминалом из нескольких потоков синхронизацию типа ReentrantLock и
synchronized следует использовать с большой осторожностью, так как можно
получить взаимную блокировку потоков. Если функция потока использует
синхронизацию в целях гарантии консистентного состояния и при этом
осуществляется вызов метода некоторого внешнего объекта, то не следует
осуществлять этот вызов внутри блока синхронизации. Вместо этого следует
использовать временную переменную для сохранения ссылки на объект и осуществить
вызов с использованием этой переменной.

Например, имеется некий поток, осуществляющий чтение последовательности сделок
из файла и осуществляющий перенаправление этих сделок некоторому абстрактному
потребителю. Этот поток представлен в виде сервиса и снабжен методом, который
позволяет остановить чтение потока и трансляцию сделок. Поскольку этот сервис
подразумевает возможность обращения из нескольких потоков, то для гарантии
согласованного состояния (сервис в работе/сервис остановлен) используются блоки
синхронизации. Один для изменения состояния сервиса

	public void stopReadingUpdates() {
		lock.lock();
		try {
			if ( started ) {
				started = false;
			}
		} finally {
			lock.unlock();
		}
	}

другой для проверки этого состояния

	public void consumeUpdate(L1Update update, long sequenceID) {
		lock.lock();
		try {
			if ( started ) {
				consumer.consume(update);
			}
		} finally {
			lock.unlock();
		}
	}

Проблема данной реализации в том, что потребитель, которому передается
управление, может обратиться к ресурсу, который заблокирован другим потоком и
который из этого же потока пытаться остановить сервис вызовом метода
stopReadingUpdates. Таким образом, два потока заблокируют друг друга навсегда:
один поток будет ожидать освобождения ресурса, занимая лок, который нужен для
освобождения ресурса. А второй поток не сможет продолжить работу что бы
освободить лок, так как будет ожидать освобождения лока при входе в метод
stopReadingUpdates.

Что бы решить данную проблему следует использовать временную переменную ВСЕГДА,
когда управление передается внешнему объекту. Такой подход позволит осуществлять
любой рефакторинг, не беспокоясь о проблемах синхронизации не связанных между
собой компонентов системы. Безопасная с точки зрения блокировок реализация
метода consumeUpdate с использованием временной переменно может выглядеть
следующим образом:

	public void consumeUpdate(L1Update update, long sequenceID) {
		L1UpdateConsumer dummy = null;
		lock.lock();
		try {
			if ( started ) {
				dummy = consumer;
			}
		} finally {
			lock.unlock();
		}
		if ( dummy != null ) {
			dummy.consume(update);
		}
	}

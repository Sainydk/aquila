Самый простой вариант для любых интервалов

Берем период в минутах от и до. Запрашиваем читалку для тиков за указанный
период. Читаем тики и собираем их в последовательность свечек. Данный процесс
можно выполнять последовательно читая тики.

--------------------------------------------------------------------------------
Минутные интервалы

Базовый таймфрейм - M1. Кэшируются данные минутных свечек за каждый день.
Такой период выбран для того, что бы не перестраивать кэш после каждой
торговой сессии. Приблизительный размер файла составляет:

    14 часов * 60 минут = 840 записей на файл

За основу используются тиковые данные, сгруппированные в ежедневные сегменты.
Рассматриваем период от и до. Определяем сегменты, входящие в указанный период.
При переходе к следующему сегменту, проверяем наличие и валидность кэша. При
необходимости перестраиваем кэш, считывая все сделки за день. После чего
открываем сегмент кэш-а на чтение и вставляем его содержимое в общую
последовательность.

Для интервалов Mx где x > 1 проще всего использовать базовый итератор.
Однако при работе с лимитами по количеству свечей (типовое требование)
необходимо знать сколько элементов в последовательности. А это уже не позволяет
использовать декорацию базового итератора в чистом виде. Необходимо строить
кэш для каждого таймфрейма. Для интервалов > 1 минуты, кэш минуток используется
в качестве основы для построения кэшей других интервалов. Кеширование сегментов
позволяет узнать количество свечей в сегменте.

--------------------------------------------------------------------------------
Часовые интервалы

Кэшируются данные часовых свечек за каждый месяц. Приблизительный размер файла
составляет:

    14 часов * 30 дней = 420 записей на файл

За основу используются ежедневные сегменты минутных свечей. Определяем дневные
сегменты, входящие в этот период. При открытии файла сегмента, проверяем наличие
и валидность кэша. При необходимости перестраиваем кэш - считываем все минутные
свечки за период и агрегируем их в часовые. После чего открываем сегмент кэша на
чтение и возвращаем его пользователю.

Для интервалов более 1 часа использовать подход, аналогичный описанному
в разделе Минутные интервалы.

--------------------------------------------------------------------------------
Дневные интервалы

Кэшируются данные дневных свечек за каждый год. Приблизительный размер файла
составляет:

    365 дней = 365 записей на файл

За основу используются данные часовых свечей. Рассматриваем период от и до.
Проверяем валидность кэша, путем анализа сегмента данных с часовыми свечками.
При необходимости перестраиваем кэш, считываем часовые свечки за всю историю
и агрегируем их в дневные. После чего открываем сегмент кэша на чтение и
возвращаем его пользователю.

Для интервалов более 1 дня использовать подход, аналогичный описанному
в разделе Минутные интервалы.

--------------------------------------------------------------------------------
Актуальность кэша

Для файла кэша важно определить, представляет-ли кэш актуальные данные
или они устарели. Каждый файл кэша сопровождается заголовком, содержащим
информацию об исходных сегментах данных. Валидация кэша включает в себя
следующие проверки:
1) Сравнить количество исходных сегментов. Если количество отличается, значит
   нужно перестроить кэш.
2) Хэш-коды исходных сегментов должны совпадать с содержимым заголовка.

--------------------------------------------------------------------------------
Формат файла кэша

Содержит:
*) 1 строка - идентификатор формата OHLCVvX где X - номер версии
*) 2 строка - количество исходных сегментов, использованных для построения кэша
*) 3 строка - количество элементов последовательности (количество свечей)
*) Cтроки с дескрипторами исходных сегментов в порядке агрегации. Каждый
дескриптор описывает один исходный файл в формате hash path, где hash - хэш код
исходного сегмента, path - путь к исходному сегменту.
*) Строки элементов

--------------------------------------------------------------------------------
Как это должно работать в комплексе (сверху-вниз).

Общий подход такой - SymbolSegmentStorage позрачно кэширует сегменты
соответствующих таймфреймов. Кеширование выполняется в момент запроса сегмента
или проверки его существования. Сборка сегментов в единую последовательность
выполняется одинаково независимо от таймфрейма. Верхнеуровневое и вложенные
хранилища выполняют функцию маршрутизатора к соответствующему хранилищу
сегментов. Сегменты имеют небольшой размер, что бы избежать частого перестроения
при изменении данных исходного уровня.

Исходным требованием к системе является запрос последних N-свечей. Будем
отталкиваться от реализации этого базового требования. Интерфейс хранилища
(CandleStorage implements MDStorage<SymbolTimeFrame, Candle>) обеспечивает
создание итераторов для перебора свечей в разрезе символа и таймфрейма с
возможностью фильтрации по периоду и количеству свечей.

Хранилище делегирует вызов соответствующему подчиненному хранилищу,
ассоциированному с временной единицей (ChronoUnit#MINUTES, HOURS, DAYS).
В случае запроса данных по неподдерживаемым единицам выбрасывается исключение.

Подчиненное хранилище имеет одинаковую организационную структуру, независимо от
связанной временной единицы. Оно разделено на две части:
1) Кэш базового таймфрейма выполняет обработку исходных данных или кэша
нижестоящего таймфрейма. Данный компонент обеспечивает доступ к сегментам
единичных интервалов (1 минута, 1 час, 1 день) соответствующей временной
единицы. Данный компонент реализует интерфейсы CandleStorage и
SymbolSegmentStorage для этих таймфреймов.
2) Кэш крупных интервалов работает на базе кэша базового таймфрейма. Реализует
интерфейс CandleStorage для соответствующего таймфрейма. Реализация кэша данного
типа едина для всех интервалов. Здесь различия лишь экземпляре таймфрейма,
который используется для определения периода агрегации.


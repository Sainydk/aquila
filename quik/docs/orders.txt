Отражение заявок.

Проблема 1: порядок поступления данных от QUIK неопределен. При выставлении
собственной заявки, строка в таблице заявок может прийти раньше, чем локальный
экземпляр заявки будет переведен из ожидаемых в зарегистрированные. В дальнейшем
попытка перевести эту заявку в разряд зарегистрированных приведет к провалу.
Так же в связи с этим последует потери событий для наблюдателей, которые
подписались на локально-созданную заявку, но которая уже не будет обновляться. 

Проблема 2: является подвидом проблемы 1 и касается заявок, которые создаются
вне программы, например через торговый терминал. Так как порядок поступления
данных от QUIK неопределен, нельзя гарантировать, что на момент получения
строки таблицы заявок, все другие объекты бизнес модели связанные с заявкой
уже будут иметь отражение в программе.

Проблема 2: смена статуса вчерашних заявок никак не передается. В связи с этим
получается рассинхронизация: локально заявка активна, а реально заявка отменена.
А при попытке отменить такую заявку в ответ на транзакцию всегда будет ошибка.

--------------------------------------------------------------------------------

Сигналом к обработке заявок служит любое из следующих событий:

1) обновление кэша таблицы заявок
2) обновление кэша таблицы собственных сделок
3) регистрация новой заявки (OnOrderAvailable)
4) регистрация нового инструмента
5) регистрация нового портфеля
6) получен ответ на транзакцию
7) обновление кэша таблицы позиций?

Обработка заявок выполняется в два этапа:

1) обрабатываются все активные заявки из списка зарегистрированных заявок
2) обрабатываются все кэш-записи, которые не задействовались на предыдущем этапе

Задача на первом проходе - согласовать состояние существующих активных заявок.
Существующая заявка означает что нужные инструмент и портфель уже доступны
локально.

1) заявки в статусе FILLED, KILLED, FAILED игнорируются
2) для заявки в статусе ACTIVE выполняется контроль и согласование состояния
по кэшу таблиц заявок и собственных сделок. При наличии новых сделок
генерируются события по сделкам. Заявка согласована, когда кол-во по сделкам и
колво в кэше заявки совпадают.
3) если после согласования исполненное кол-во совпадает с кол-вом заявки, заявка
переводится в статус FILLED а дата сведения выставляется по последней сделке
4) если кэш указывает на KILLED и исполненное кол-во в кэше совпадает с
согласованным кол-вом, то выставляется KILLED (что в комбинации с qty.rest
отличным от начального приводит к генерации OnPartiallyFilled)

Задача на втором проходе - создать экземпляры заявок, созданных через торговый
терминал или зарегистрированных ранее, чем была запущена програма. Этот этап
выполняется только в том случае, если нет отправленных но еще необработанных
транзакций (проверяется через сервис API). Такая проверка необходима, что бы не
занять место существующего PENDING экземпляра заявки, ожидающего ответа на
транзакцию.

1) для каждой кэш-записи, для которой нет зарегистрированной заявки, создается
экземпляр заявки. Далее согласуется исполненное количество по кэшу сделок. Если
полученные сделки не соответствуют исполненному количеству по кэшу заявки,
то заявка пропускается (до того момента, пока все таблицы не станут содержать
согласованные данные). 

Примечания:
Насчет завершенных заявок, которые образуются в результате трансляции данных
из QUIK. По таким заявкам не генерируется никаких событий, кроме available.
Экземпляр такой заявки создается на основании записи кэша таблицы заявок и
только в случае полного согласования с данными по кэшу сделок.

Остался вопрос согласования с позицией по портфелю. Все таки это очень важно,
так как обработка заявки наверняка будет связана с получением текущей позиции,
которая актуальна на момент обработки заявки.

Есть идея сохранять время получения последнего обновления таблицы позиций и
после этого времени можно выполнить расчет позиции по сделкам. Но так как в
таблице позиций нет времени актуальности, 100% точность не гарантируется. В
принципе, все время работы можно актуализировать текущую позицию по сделкам. Для
этого нужно просто отловить первое обновление таблицы позиций. Но тут тоже 100%
уверенности нет, так как первое обновление может быть битым. Думаем...

Если для каждой записи кэша хранить ее время, можно решить проблему согласования
данных по текущей позиции? Как? Если гарантировать, что момент согласования
не может выполняться параллельно с обновлением кэша, то в итоге... Это не решает
проблемы, так как при обновлении кэша таблицы позиций данные по сделки могут
еще не прийти.

Наверное, самый оптимальный вариант это сохранять позиции на начало сессии,
скажем данные за несколько минут до начала сессии и есть начальные позиции
(несколько минут, что бы снизить требование по синхронизации времен локальной
и удаленной машины). Дальше считать по сделкам. Но как быть если в течение дня
зачислятся бумаги на счет?

Эврика! Есть же позиция на открытии. Но пока делаем без согласования позиции. 



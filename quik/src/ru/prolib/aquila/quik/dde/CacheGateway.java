package ru.prolib.aquila.quik.dde;

import ru.prolib.aquila.core.data.row.Row;
import ru.prolib.aquila.dde.DDEException;

/**
 * Интерфейс шлюза к кэшу DDE-таблицы.
 * <p>
 * Шлюз знает все о требованиях, предъявляемым к импортируемой таблице и
 * абстрагирует обработчик таблицы от деталей реализации кэша.
 */
public interface CacheGateway {
	
	/**
	 * Получить список обязательных заголовков таблицы.
	 * <p>
	 * @return список заголовков
	 */
	public String[] getRequiredHeaders();
	
	/**
	 * Кэшировать ряд таблицы.
	 * <p> 
	 * @param row ряд
	 * @throws DDEException ошибка конвертирования ряда
	 */
	public void toCache(Row row) throws DDEException;
	
	/**
	 * Получить ключевое значение ряда.
	 * <p>
	 * При передаче данных QUIK никак не сигнализирует о полной очистке таблицы
	 * (например перед началом торговой сессии). Попытка привязаться к
	 * поступлению строки заголовков успехом не увенчалась, так как заголовки
	 * в этом случае не передаются. Единственный способ как то определить
	 * необходимость очистки кэша - это привязаться к некоторому ключевому
	 * значению строки, которое является неизменным в течение всего времени
	 * нахождения соответствующей строки в таблице. Например, для таблицы заявок
	 * это номер заявки. Для инструментов или счетов это может быть
	 * комбинированная строка значений нескольких элементов ряда. 
	 * <p>
	 * На данный момент нет твердой уверенности, что таблица всегда очищается
	 * полностью. По этому, отлавливать момент очистки кэша по одной только
	 * строке (например первой) не представляется очень надежным вариантом. 
	 * Например, для таблицы заявок некоторые заявки могут быть перенесены на
	 * следующий день. И если на месте первой строки окажется тот же ордер, что
	 * был и вчера, то следующие строки останутся в кэше, даже если их реально
	 * в таблице уже нет. 
	 * <p>
	 * По этому, ключевое значение хранится для каждой строки. Сигналом
	 * к очистке кжша в данном случае будет несоответствие ключевого значения
	 * хотя бы для одной строки (кроме того случая, когда новая строка
	 * добавляется в конец кэша).
	 * <p>
	 * Правда гипотетически здесь возможна ситуация, когда пришла только часть
	 * таблицы, при обработке которой кэш признается недействительным и в этом
	 * случае часть строк будет потеряна. Но поскольку кэш не должен
	 * рассматриваться в качестве надежного источника данных, такая ситуация не
	 * должна приводить к критическим последствиям.
	 * <p>
	 * Реализация шлюза конкретной таблицы посредством данного метода
	 * обеспечивает доступ к ключевому значению, однозначно идентифицирующему
	 * ряд таблицы. Тип данных не имеет значения. Главное - обеспечить
	 * возможность корректного сравнения колючевых значений посредством вызова
	 * метода {@link Object#equals(Object)}. 
	 * <p>
	 * @param row ряд
	 * @return ключевое значение ряда
	 * @throws DDEException ошибка доступа к элементу ряда
	 */
	public Object getKeyValue(Row row) throws DDEException;
	
	/**
	 * Генерировать событие об обновлении кэша.
	 */
	public void fireUpdateCache();
	
	/**
	 * Очистить кэш.
	 */
	public void clearCache();

}

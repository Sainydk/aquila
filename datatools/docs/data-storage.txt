- Концепция хранения рыночных данных

- State table & state update

Большинство данных можно представить в виде таблиц. Например, таблица инструментов
содержит строки, каждая из которых соответствует отдельному инструменту и состоит
из полей, соответствующих атрибутам инструмента. С течением времени атрибуты инструмента
не обязательно изменяются одновременно. С каждым обновлением могут быть
обновлено один или более атрибутов инструмента, в то время как другие атрибуты
остаются неизменными. Таким образом, наиболее рациональным для такого рода данных
видится хранение кортежей измененных атрибутов, когда обновление содержит не полный
набор значений соответствующих атрибутов, а набор пар, идентифицирующих какой атрибут
какое значение принимает в рамках данного обновления. Таблицы, представляющие данные
такого рода будем называть таблицами состояний, а историю их изменений - историей состояния.

- State full refresh

Рассмотрим проблему на примере таблицы инструментов. При хранении только истории изменений,
мы не знаем какие конкретно поля изменяются с тем или иным обновлением и для того, что бы
восстановить состояние инструмента на определенную дату придется перечитать всю историю, что
может занять много времени. Для решения этой проблемы достаточно с определенной периодичностью
добавлять в последовательность обновлений запись, содержащую полный набор атрибутов. Поскольку
внутри дня основные атрибуты изменяются не часто, достаточно делать подобную запись один раз
в день в самом его начале. Используя специальный маркер записи можно найти ближайшее к
интересующей дате полное обновление и использовать его для первичной инициализации атрибутов
инструмента. Далее, применив небольшое количество изменений наступивших после, получить
состояние на интересующую дату.



Stream table & stream update

Другой пример - таблица сделок. Каждая строка этой таблицы представляет собой информацию
об отдельной сделке совершенной на рынке. Строки таблицы сделок не изменяются после
добавления. Таким образом, для хранения информации о сделках достаточно использовать
последовательность значений атрибутов. Поскольку в этом случае всегда происходит
обновление всех атрибутов, а набор атрибутов неизменен, сопоставлять значениям
идентификаторы атрибутов нет необходимости. Каждая строка таблицы может быть представлена
в виде набора значений, порядковый номер которого определяет соотвествующий атрибут
таблицы. Таблицы, представляющие данные подобного типа будем называть потоком обновлений.

Поскольку информация сохраняется для целей последующего воспроизведения, наиболее
значимым атрибутом каждого обновления независимо от типа таблицы является временной
маркер, которому это обновление соответствует. Используя этот маркер можно выполнять отбор
записей в пределах заданного периода. В зависимости от характера данных, также могут быть
важны некоторые дополнительные характеристики обновлений. Например, для обновлений связанных
с инструментами важно иметь возможность фильтровать обновления конкретных инструментов.
Тоже самое касается истории сделок. Что бы отобрать сделки только по одному инструменту,
необходимо обеспечить наличие соответствующего проиндексированного поля в базе данных.
Поскольку рыночные данные всегда связаны с каким-либо финансовым инструментом, маркер
инструмента является обязательным в рамках хранилища рыночных данных.

В конечном итоге, для хранения рыночных данных нет необходимости в сложной структуре базы
данных. Достаточно обеспечить хранение ключевых полей, идентифицирующих время обновления и
инструмент. Само содержимое обновления может храниться в произвольном виде, понятным
только драйверу-упаковщику. Для воспроизведения ситуации достаточно выполнить обновления
соответствующих объектов в порядке поступления записей-обновлений. При таком подходе
можно достаточно свободно расширять список атрибутов, изменяя только реализацию упаковщика
и сохраняя структуру базы данных неизменной.


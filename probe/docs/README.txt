Эмулятор терминала

Современная биржевая торговля является высокотехнологичным процессом, что
подразумевает активный поиск и отработку множества различных подходов.
Таким образом, значительный объем работ представляют собой исследования и
эксперименты. Однако, выполнение различных экспериментов в процессе реальных
торгов нерационально по вполне очевидным причинам: это требует много времени и
средств. Помимо этого, немаловажным этапом в процессе внедрения технологических
решений также является тестирование и отладка. Все это требует наличия
соответствующих инструментов. 

Задача данного проекта - обеспечить реализацию принятой модели торгового
терминала, в целях воспроизведения работы реального терминала с максимальной
точностью в различных режимах выполнения: реального времени или с
максимально-доступной скоростью исполнения. Реализация должна учитывать
особенности различных элементов и этапов торгового процесса: типов инструментов,
портфелей и позиций, различных типов заявок, эмуляции сетевых задержек и обрывов
связи и т.п. Внутренний программный дизайн терминала должен обеспечивать
возможность реализации специфических особенностей элементов торгового процесса
путем внедрения новых или путем замены существующих программных компонентов в
рамках эмулятора терминала.




--------------------------------------------------------------------------------
Переработать

И еще, хотелось бы получить такой конструктор, что бы можно было собирать
терминал из различных реализаций. Например, получать инструменты и сделки по ним
из квика, а обработку заявок и учет портфеля и позиций выполнять эмулятором.
Но пожалуй это будет слишком сложно и недостаточно востребованно.

Дано: Поток тиковых данных, соответствующих сделкам.

Необходимо контролировать:

* Атрибуты инструмента
* Исполнение заявок
* Стоимость текущей позиции
* Атрибуты портфеля
* Время терминала
* Эмулировать клиринги (?)

Вопрос: в какой последовательности обрабатывать соответствующие типы объектов?

Способ учета вариационки, списания денег при открытии позиции, действия при
экспирации и другие тонкости известны только конкретной реализации инструмента.
Например, для фьючерсов и акций это будут различные алгоритмы. Следовательно,
данные нужно направлять на вход драйверу инструмента, который будет выполнять
абсолютно все необходимые действия. Никаких обособленных классов обработки
объектов позиций или портфелей не будет (по крайней мере пока). Поскольку способ
учета на балансе так же зависит от специфики инструмента, то и действия,
приводящие к изменению позиций (эмуляция исполнения заявок) будут выполняться в
рамках реализации конкретного инструмента. Все вышеописанное означает, что
никакой проблемы согласования данных на практике существовать не будет.

Что бы обеспечить потенциал интеграции функций эмулятора как подменяемую часть
реализаций других терминалов, необходимо реализовывать соответствующий
функционал в виде отдельных модулей. Например, функцию эмуляции исполнения
заявок на срочном рынке, принимающую инструмент и тик-сделку, которая служит
основанием для принятия решения об исполнении существующих заявок. Такая функция
рассматривает инструмент как уже актуализированный (приведенный в соотвествие
с последними данными). Инструмент используется для доступа к терминалу,
который в свою очередь обеспечивает доступ к объектам портфеля, позиций и
заявок.

Здесь нужно учесть тонкость. Для того, что бы обеспечить работу тестового
портфеля в любом случае необходимо некое предварительное описательное действие,
характеризующее виртуальный портфель. Как минимум нужно указать начальный баланс
портфеля. И здесь возникает вопрос, а действительно-ли алгоритм учета на балансе
должен выполняться в рамках инструмента? Все-таки каждый отдельный счет
представляет собой некий подход к учету активов определенных типов.

Если с представлением интерфейсов низкоуровневых деталей особых сложностей нет,
то вывести некий унифицированный способ связывания источника данных с
обработчиком представляется затруднительным. Тип единицы входных данных может
различаться в зависимости от источника данных. Например, тестовый проход может
быть выполнен с использованием свечей или на основе сделок. Для этих двух
случаев легко представить контракты с соответствующими типами данных в
сигнатурах методов, но эти интерфейсы нельзя будет свести к общему полиморфному
без использования шаблонов. В общем из-за сложностей с представлением
архитектуры предлагается действовать от реализации.

Прежде всего, что такое тестовый прогон? Тестовый прогон, это эмуляция работы
терминала с использованием исторических данных за определенный период времени. 
Каким образом будет выполняться настройка и запуск тестового прогона? Поскольку
используются данные за период, как минимум настройка тестового прогона
подразумевает указание этого самого периода. Тестовый прогон выполняется в
отдельном потоке. Запуск тестового прогона инициируется вызовом метода start
терминала. Прогон считается завершенным если достигнут конец данных или конец
периода тестирования. В процессе исполнения тестовый прогон может быть прерван
посредством вызова метода stop терминала. После завершения тестового прогона
терминал переводится в состояние stopped (то есть конец прогона можно
отслеживать по OnStopped терминала).

Что насчет многопоточности при тестовом прогоне? Пока оставить как есть с
очередью событий в отдельном потоке. Впоследствии нужно прогнать длительных
тестов на соответствие результатов прогона при параллельной загрузке компа.

План минимум.

Реализовать для тестового прогона базовое функционирование инструментов на
примере какой нибудь простой бумаги типа акций GAZP. В результате должна
получиться заготовка терминала, доступная к использованию в рамках текущей
реализации UI, с возможностью выбора периода тестового прогона.

Детали.

Тестовый прогон всегда связан с периодом тестирования. 

, время терминала
на момент старта устанавливается на начало периода тестирования. Это позволит
корректно отработать старт стратегий, требующих время для вычисления начальных
параметров (загрузка ряда свечей для начального расчета индикаторов, определение
активного фьючерса для торговли, и т.п.). 

Эмуляция работы выполняется только по тем инструментам, для которых был вызван
метод requestSecurity. Если исторические данные по запрошенному инструменту
недоступны в принципе, это приведет к вызову соответствующего метода наблюдателя
системных событий. 

Для выполнения реальной работы в ходе тестового прогона необходимо что бы на
момент запуска на временной шкале эмулятора было зарегистрировано хотя бы одно
событие. Если стратегия запросила через requestSecurity хотя бы один инструмент
и внутри РП есть данные на этот инструмент, то в связи с этим инструментом будет
выполняться регистрация событий. Другой способ предоставить эмулятору опорные
данные - это зарегистрировать событие путем обращения к планировщику терминала.
Эмулятор автоматически транслирует обращения к планировщику в соответствующие
события на временной шкале эмулятора. Таким образом, эмулятор получает работу
как минимум на один шаг в будущее. Если в процессе обработки событий следующего
шага будут зарегистрированны новые события, то цикл будет продолжаться до тех
пор, пока не закончатся события или не будет достигнута граница РП. 


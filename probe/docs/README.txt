Эмулятор терминала


Этапы реализации:

Этап 1 (в работе): Организация рабочего цикла.

Пакет Timeline является основой эмулятора и включает в себя следующие
компоненты:

1) Классы для организации очереди событий;
2) Реализация планировщика событий (core.Scheduler) под хронологию;
3) Сервис исполнения и управления очередью событий;

--------------------------------------------------------------------------------
Переработать

И еще, хотелось бы получить такой конструктор, что бы можно было собирать
терминал из различных реализаций. Например, получать инструменты и сделки по ним
из квика, а обработку заявок и учет портфеля и позиций выполнять эмулятором.
Но пожалуй это будет слишком сложно и недостаточно востребованно.

Дано: Поток тиковых данных, соответствующих сделкам.

Необходимо контролировать:

* Атрибуты инструмента
* Исполнение заявок
* Стоимость текущей позиции
* Атрибуты портфеля
* Время терминала
* Эмулировать клиринги (?)

Вопрос: в какой последовательности обрабатывать соответствующие типы объектов?

Способ учета вариационки, списания денег при открытии позиции, действия при
экспирации и другие тонкости известны только конкретной реализации инструмента.
Например, для фьючерсов и акций это будут различные алгоритмы. Следовательно,
данные нужно направлять на вход драйверу инструмента, который будет выполнять
абсолютно все необходимые действия. Никаких обособленных классов обработки
объектов позиций или портфелей не будет (по крайней мере пока). Поскольку способ
учета на балансе так же зависит от специфики инструмента, то и действия,
приводящие к изменению позиций (эмуляция исполнения заявок) будут выполняться в
рамках реализации конкретного инструмента. Все вышеописанное означает, что
никакой проблемы согласования данных на практике существовать не будет.

Что бы обеспечить потенциал интеграции функций эмулятора как подменяемую часть
реализаций других терминалов, необходимо реализовывать соответствующий
функционал в виде отдельных модулей. Например, функцию эмуляции исполнения
заявок на срочном рынке, принимающую инструмент и тик-сделку, которая служит
основанием для принятия решения об исполнении существующих заявок. Такая функция
рассматривает инструмент как уже актуализированный (приведенный в соотвествие
с последними данными). Инструмент используется для доступа к терминалу,
который в свою очередь обеспечивает доступ к объектам портфеля, позиций и
заявок.

Здесь нужно учесть тонкость. Для того, что бы обеспечить работу тестового
портфеля в любом случае необходимо некое предварительное описательное действие,
характеризующее виртуальный портфель. Как минимум нужно указать начальный баланс
портфеля. И здесь возникает вопрос, а действительно-ли алгоритм учета на балансе
должен выполняться в рамках инструмента? Все-таки каждый отдельный счет
представляет собой некий подход к учету активов определенных типов.

Если с представлением интерфейсов низкоуровневых деталей особых сложностей нет,
то вывести некий унифицированный способ связывания источника данных с
обработчиком представляется затруднительным. Тип единицы входных данных может
различаться в зависимости от источника данных. Например, тестовый проход может
быть выполнен с использованием свечей или на основе сделок. Для этих двух
случаев легко представить контракты с соответствующими типами данных в
сигнатурах методов, но эти интерфейсы нельзя будет свести к общему полиморфному
без использования шаблонов. В общем из-за сложностей с представлением
архитектуры предлагается действовать от реализации.

Прежде всего, что такое тестовый прогон? Тестовый прогон, это эмуляция работы
терминала с использованием исторических данных за определенный период времени. 
Каким образом будет выполняться настройка и запуск тестового прогона? Поскольку
используются данные за период, как минимум настройка тестового прогона
подразумевает указание этого самого периода. Тестовый прогон выполняется в
отдельном потоке. Запуск тестового прогона инициируется вызовом метода start
терминала. Прогон считается завершенным если достигнут конец данных или конец
периода тестирования. В процессе исполнения тестовый прогон может быть прерван
посредством вызова метода stop терминала. После завершения тестового прогона
терминал переводится в состояние stopped (то есть конец прогона можно
отслеживать по OnStopped терминала).

Что насчет многопоточности при тестовом прогоне? Пока оставить как есть с
очередью событий в отдельном потоке. Впоследствии нужно прогнать длительных
тестов на соответствие результатов прогона при параллельной загрузке компа.

План минимум.

Реализовать для тестового прогона базовое функционирование инструментов на
примере какой нибудь простой бумаги типа акций GAZP. В результате должна
получиться заготовка терминала, доступная к использованию в рамках текущей
реализации UI, с возможностью выбора периода тестового прогона.

Немного деталей.

Модификации в модели терминала -------------------------------------------------

Решено связать терминал с наблюдателями системных событий, обслуживаемых в
синхронном исполнении (далее условно - стратегия). Это связано с необходимостью
гарантировать своевременную реакцию заинтересованных наблюдателей на некоторые
системные события. В частности, стратегии должны своевременно уведомлять
терминал о необходимых для своей работы инструментах. В момент вызова
такого синхронного обработчика гарантируется, что терминал находится в валидном
состоянии. Например, в случае эмулятора стратегиям гарантируется, что состояние
позволяет использовать внутреннее время терминала для рассчета текущих
фьючерсов. А например терминал IB готов ретранслировать запросы инструментов
в удаленную систему.

Таким образом для некоторых важных моментов терминал может сам инициировать
соответствующие процедуры своих пользователей. А пользователи получают
возможность выполнять соответствующие действия, будучи освобожденными от знания
когда наступает наиболее подходящий для этого момент.

Порядок и условия работы эмулятора ---------------------------------------------

Так как тестовый прогон всегда связан с периодом тестирования, время терминала
на момент старта устанавливается на начало периода тестирования. Это позволит
корректно отработать старт стратегий, требующих время для вычисления начальных
параметров (загрузка ряда свечей для начального расчета индикаторов, определение
активного фьючерса для торговли, и т.п.). 

Эмуляция работы выполняется только по тем инструментам, для которых был вызван
метод requestSecurity. Если исторические данные по запрошенному инструменту
недоступны в принципе, это приведет к вызову соответствующего метода наблюдателя
системных событий. 

Для выполнения реальной работы в ходе тестового прогона необходимо что бы на
момент запуска на временной шкале эмулятора было зарегистрировано хотя бы одно
событие. Если стратегия запросила через requestSecurity хотя бы один инструмент
и внутри РП есть данные на этот инструмент, то в связи с этим инструментом будет
выполняться регистрация событий. Другой способ предоставить эмулятору опорные
данные - это зарегистрировать событие путем обращения к планировщику терминала.
Эмулятор автоматически транслирует обращения к планировщику в соответствующие
события на временной шкале эмулятора. Таким образом, эмулятор получает работу
как минимум на один шаг в будущее. Если в процессе обработки событий следующего
шага будут зарегистрированны новые события, то цикл будет продолжаться до тех
пор, пока не закончатся события или не будет достигнута граница РП. 

== ниже - устарело ==
Более рациональным видится вариант, при котором дескрипторы всех запрошенных
инструментов можно получить через специальный метод терминала. Сбрасывать этот
список после останова терминала. Заполнение списка обеспечить в базовой
реализации метода requestSecurity. Применение этому списку можно найти и в
других случаях. Например, для дополнительных проверок корректности настроек 
экспорта по реально-запрошенным инструментам из систем шедеврального типа
(QUIK). Но в этом случае все равно существует проблема определения момента,
когда следует запускать процедуру прогона исторических данных. Ведь вызов
requestSecurity может быть осуществлен например в обработчиках
OnStarted/OnConnected или просто после вызова метода start терминала. К тому же
конечное количество вызовов requestSecurity в момент обработки одного из них
остается неизвестным.

Подключение инструмента в процесс прогона по ходу работы может привести к
неожиданным потерям данных. Например, первый запрос requestSecurity запускает
поток трансляции данных и управление передается созданному потоку данных. Этот
поток успевает оттранслировать несколько сделок запрошенного инструмента, смещая
время терминала вглубь тестового периода. Далее управление возвращается
основному потоку, который осуществляет запрос следующего инструмента. Но сделки
по этому следующему инструменту в лучшем случае начнут транслироваться с
текущего времени терминала, которое уже не совпадает с началом тестового периода.
Естественно, это совсем не то, что требуется получить.

Видимо оптимальным вариантом остается условное требование запроса как минимум
одного инструмента до завершения трансляции события OnConnected. Это конечно не
очень гибкое решение, но иного варианта как получить полный список инструментов
для тестового прогона пока не просматривается. По крайней мере, выполнение этого
соглашения можно отслеживать программно и информировать пользователя в случае
неисполнения (через OnPanic). Дополнительной альтернативой может служить
запуск задачи через планировщик. Но поскольку это значительно более сложная
реализация, то остается на будущее.

Или можно сформулировать задачу иначе: тестовый прогон выполняется пока в
наличии имеются исторические данные или не будет достигнут конец периода
прогона. Таким образом, если на момент после обработки события OnConnected
не будет определен ни один источник данных (или что либо, что позволит
переместить терминал во времени периода тестирования), то это будет
соответствовать признаку конца данных, что автоматически приведет к завершению
тестового прогона.

В случае возникновения проблем связанных с параллелизацией потоков трансляции
данных и диспетчеризации событий (как их детектировать пока не совсем ясно).
Избавление от параллельной трансляции событий из очереди и отработка всего
процесса в один поток может быть выполнена путем подмены очереди событий при
инстанцировании терминала.

Фасад доступа к хранилищу исторических данных позволяет инстанцировать ридеры
данных. При этом, для создания ридера требуется указать дескриптор инструмента
и временной интервал отбираемых данных.

Для фьючерсов:

Размер лота, размер тика, точность цены, даты начала и конца обращения, дата
экспирации неизменны и задаются в конфигурации инструмента. Расчетная цена нужна
для вычисление ГО, верхнего и нижнего лимитов цены. Для фьючерсов с ценой
в валюте SUR цена тика равна размеру тика. Для фьючерсов с ценой в валюте
отличной от SUR стоимость тика расчитывается как доля от индикативного курса
соответствующей валюты на время соответствующего клиринга. Величина доли
неизменна и указывается в конфигурации инструмента.

Клиринг по позициям:

Нужно где-то учитывать задействованное ГО позиции. Между клирингами не забывать
пересчитывать: ГО будет меняеться при изменении расчетной цены.



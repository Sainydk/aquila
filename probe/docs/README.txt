Эмулятор терминала


Этапы реализации:

Этап 1 (в работе): Организация рабочего цикла.

Пакет Timeline является основой эмулятора и включает в себя следующие
компоненты:

1) Классы для организации очереди событий;
2) Реализация планировщика событий (core.Scheduler) под хронологию;
3) Сервис исполнения и управления очередью событий;

--------------------------------------------------------------------------------
Переработать

И еще, хотелось бы получить такой конструктор, что бы можно было собирать
терминал из различных реализаций. Например, получать инструменты и сделки по ним
из квика, а обработку заявок и учет портфеля и позиций выполнять эмулятором.
Но пожалуй это будет слишком сложно и недостаточно востребованно.

Дано: Поток тиковых данных, соответствующих сделкам.

Необходимо контролировать:

* Атрибуты инструмента
* Исполнение заявок
* Стоимость текущей позиции
* Атрибуты портфеля
* Время терминала

Вопрос: в какой последовательности обрабатывать соответствующие типы объектов?

Способ учета вариационки, списания денег при открытии позиции, действия при
экспирации и другие тонкости известны только конкретной реализации инструмента.
Следовательно, данные нужно направлять на вход драйверу инструмента, который
будет выполнять абсолютно все необходимые действия. Никаких обособленных классов
обработки объектов позиций или портфелей не будет. Поскольку способ учета на
балансе так же зависит от специфики инструмента, то и действия, приводящие к
изменению позиций (эмуляция исполнения заявок) будут выполняться в рамках
реализации конкретного инструмента. Все вышеописанное означает, что никакой
проблемы согласования данных на практике существовать не будет.  

Что бы обеспечить потенциал интеграции функций эмулятора как подменяемую часть
реализаций других терминалов, необходимо реализовывать соответствующий
функционал в виде отдельных модулей. Например, функцию эмуляции исполнения
заявок на срочном рынке, принимающую инструмент и тик-сделку, которая служит
основанием для принятия решения об исполнении существующих заявок. Такая функция
рассматривает инструмент как уже актуализированный (приведенный в соотвествие
с самыми последними данными). Инструмент используется для доступа к терминалу,
который в свою очередь обеспечивает доступ к объектам портфеля, позиций и
заявок.

Здесь нужно учесть тонкость. Для того, что бы обеспечить работу тестового
портфеля в любом случае необходимо некое предварительное описательное действие,
характеризующее виртуальный портфель. Как минимум нужно указать начальный баланс
портфеля. И здесь возникает вопрос, а действительно-ли алгоритм учета на балансе
должен выполняться в рамках инструмента? Все-таки каждый отдельный счет
представляет собой некий подход к учету активов.

Если с представлением интерфейсов низкоуровневых деталей особых сложностей нет,
то вывести некий унифицированный способ связывания источника данных с
обработчиком представляется затруднительным. Тип единицы входных данных может
различаться в зависимости от источника данных. Например, тестовый проход может
быть выполнен с использованием свечей или на основе сделок. Для этих двух
случаев легко представить контракты с соответствующими типами данных в
сигнатурах методов, но эти интерфейсы нельзя будет свести к общему полиморфному
без использования шаблонов. В общем из-за сложностей с представлением
архитектуры предлагается действовать от реализации.

Прежде всего, что такое тестовый прогон? Тестовый прогон, это эмуляция работы
терминала с использованием исторических данных за определенный период времени. 
Каким образом будет выполняться настройка и запуск тестового прогона? Поскольку
используются данные за период, как минимум настройка тестового прогона
подразумевает указание этого самого периода. Тестовый прогон выполняется в
отдельном потоке. Запуск тестового прогона инициируется вызовом метода start
терминала. Прогон считается завершенным если достигнут конец данных или конец
периода тестирования. В процессе исполнения тестовый прогон может быть прерван
посредством вызова метода stop терминала. После завершения тестового прогона
терминал переводится в состояние stopped (то есть конец прогона можно
отслеживать по OnStopped терминала).

Что насчет многопоточности при тестовом прогоне? Пока оставить как есть с
очередью событий в отдельном потоке. Впоследствии нужно прогнать длительных
тестов на соответствие результатов прогона при параллельной загрузке компа.

План минимум.

Реализовать для тестового прогона базовое функционирование инструментов на
примере какой нибудь простой бумаги типа акций GAZP. В результате должна
получиться заготовка терминала, доступная к использованию в рамках текущей
реализации UI, с возможностью выбора периода тестового прогона.

Немного деталей.

Эмуляция работы выполняется только по тем инструментам, для которых был вызван
метод requestSecurity. Если исторические данные по запрошенному инструменту в
принципе недоступны, то это приводит к эмуляции принудительного останова
терминала (сначала OnRequestSecurityError, затем OnPanic).

Так как тестовый прогон всегда связан с периодом тестирования, время терминала
на момент старта устанавливается на начало периода тестирования. Это позволит
корректно отработать старт стратегий, требующих время для вычисления начальных
параметров (загрузка ряда свечей для начального расчета индикаторов, определение
активного фьючерса для торговли, и т.п.). 

Без указания (запроса через requestSecurity) хотя бы одного инструмента в виду
отсуствия данных выполнить тестовый прогон в принципе невозможно. Это связано с
тем, что перемещение терминала во времени выполняется в порядке перебора
исторических данных. Если тестируемая стратегия не выполнила запрос инструментов
(по ошибке или не предусмотрено) то после запуска поток терминала будет
находиться в бесконечном цикле ожидания выбора инструментов. По этому нужно
останавливать терминал. 

Как бы решить эту проблему в рамках терминала?

Можно, конечно, событие OnRequestSecurity в терминал добавить и отслеживать на
момент запуска тестируемых стратегий. Но этот вариант не нравится, так как
кроме этого случая данное событие маловероятно где понадобится. Кроме того,
событие будет так же асинхронным, так что не факт, что после запуска в одном
потоке, другой поток, обрабатывающий очередь событий, успеет поставить эту
информацию в обработчик.

Более рациональным видится вариант, при котором дескрипторы всех запрошенных
инструментов можно получить через специальный метод терминала. Сбрасывать этот
список после останова терминала. Заполнение списка обеспечить в базовой
реализации метода requestSecurity. Применение этому списку можно найти и в
других случаях. Например, для дополнительных проверок корректности настроек 
экспорта по реально-запрошенным инструментам из систем шедеврального типа
(QUIK). Но в этом случае все равно существует проблема определения момента,
когда следует запускать процедуру прогона исторических данных. Ведь вызов
requestSecurity может быть осуществлен например в обработчиках
OnStarted/OnConnected или просто после вызова метода start терминала. К тому же
конечное количество вызовов requestSecurity в момент обработки одного из них
остается неизвестным.

Подключение инструмента в процесс прогона по ходу работы может привести к
неожиданным потерям данных. Например, первый запрос requestSecurity запускает
поток трансляции данных и управление передается созданному потоку данных. Этот
поток успевает оттранслировать несколько сделок запрошенного инструмента, смещая
время терминала вглубь тестового периода. Далее управление возвращается
основному потоку, который осуществляет запрос следующего инструмента. Но сделки
по этому следующему инструменту в лучшем случае начнут транслироваться с
текущего время терминала, которое уже не совпадает с началом тестового периода.
Естественно, это совсем не то, что требуется получить.

Видимо оптимальным вариантом остается условное требование запроса как минимум
одного инструмента до завершения трансляции события OnConnected. Это конечно не
очень гибкое решение, но иного варианта как получить полный список инструментов
для тестового прогона пока не просматривается. По крайней мере, выполнение этого
соглашения можно отслеживать программно и информировать пользователя в случае
неисполнения (через OnPanic). Дополнительной альтернативой может служить
запуск задачи через планировщик. Но поскольку это значительно более сложная
реализация, то остается на будущее.

Или можно сформулировать задачу иначе: тестовый прогон выполняется пока в
наличии имеются исторические данные или не будет достигнут конец периода
прогона. Таким образом, если на момент после обработки события OnConnected
не будет определен ни один источник данных (или что либо, что позволит
переместить терминал во времени периода тестирования), то это будет
соответствовать признаку конца данных, что автоматически приведет к завершению
тестового прогона.

В случае возникновения проблем связанных с параллелизацией потоков трансляции
данных и диспетчеризации событий (как их детектировать пока не совсем ясно).
Избавление от параллельной трансляции событий из очереди и отработка всего
процесса в один поток может быть выполнена путем подмены очереди событий при
инстанцировании терминала.

Фасад доступа к хранилищу исторических данных позволяет инстанцировать ридеры
данных. При этом, для создания ридера требуется указать дескриптор инструмента
и временной интервал отбираемых данных.  

Для фьючерсов:

Размер лота, размер тика, точность цены, даты начала и конца обращения, дата
экспирации неизменны и задаются в конфигурации инструмента. Расчетная цена нужна
для вычисление ГО, верхнего и нижнего лимитов цены. Для фьючерсов с ценой
в валюте SUR цена тика равна размеру тика. Для фьючерсах с ценой в валюте
отличной от SUR стоимость тика расчитывается как доля от индикативного курса
соответствующей валюты на время соответствующего клиринга. Величина доли
неизменна и указывается в конфигурации инструмента.

Клиринг по позициям:

Нужно где-то учитывать задействованное ГО позиции. Между клирингами не забывать
пересчитывать: ГО будет меняеться при изменении расчетной цены.